import yfinance as yf
import pandas as pd
import matplotlib.pyplot as plt
pd.set_option('display.max_columns', None)
import numpy as np


class investment_portfolio:

    def __init__(self):         
        clmns = ['Sector','Asset Class', 'Quantity', 'Purchase Price', 'Transaction Value', 'Current Value'] 
        self.portfolio = pd.DataFrame(columns=clmns)
        return
    
    def add_asset(self, ticker, sector, asset_class, quantity, purchase_price): 
        transaction_value = quantity * purchase_price
        current_value = quantity * self.price(ticker, prd='1d').iloc[0, 0]
        self.portfolio.loc[ticker] = {'Sector': sector, 'Asset Class': asset_class, 'Quantity': quantity, 'Purchase Price': purchase_price,
                                      'Transaction Value': transaction_value, 'Current Value': current_value}
        return
    
    def price(self, tickers, prd = '1mo', itv=None):
        # Distinguising between two cases to make compatible for the graph function
        if itv !=None:
            prices = yf.download(tickers, auto_adjust=True, interval = itv, period = prd, progress = False)['Close'][::-1]
            if itv[-1] not in ['m', 'h']:
                prices.index = prices.index.date
        else:
            prices = yf.download(tickers, auto_adjust=True, period = prd, progress = False)['Close'][::-1] 
        return prices
    
    def graph(self, tickers = None, prd = 'max'):
        if tickers == None:
            tickers = self.portfolio.index.tolist()
        prices = self.price(tickers, prd)
        plt.figure()
        # Plot each ticker individually and add label
        if len(tickers) > 1:
            for column in prices.columns:
                plt.plot(prices.index, prices[column], label=column)
        else: 
            plt.plot(prices.index, prices, label=tickers)
        plt.legend()
        plt.title('Historic Stock Prices')
        plt.xlabel('Year')
        plt.ylabel('Stock Price')
        plt.tight_layout() 
        plt.show()
        return
    
    def __str__(self): 
        # Creating string instance to easily print the portfolio
        return '\nPortfolio:'+'\n'+str(self.portfolio.round(3)) 
    
    def portfolio_value(self, asset_class = False, sector = False):
        total_value = self.portfolio['Current Value'].sum().round(3)

        print(f'\nThe total portfolio value is: {total_value}\n')
        
        tickers = self.portfolio.index.tolist()
        share_per_asset = pd.DataFrame(columns = ['Share of total value (per asset)'])
        
        for ticker in tickers:
            share_per_asset.loc[ticker] = self.portfolio.loc[ticker]['Current Value']/total_value
        
        print(share_per_asset.round(3))
        
        plt.figure(figsize = (6, 6))
        plt.pie(share_per_asset['Share of total value (per asset)'], labels = share_per_asset.index)
        plt.title('Share Of Total Portfolio Value by Asset')
        plt.tight_layout()
        
        if asset_class:
            classes = self.portfolio['Asset Class'].unique()
            share_per_asset_class = pd.DataFrame(columns = ['Share of total value (per asset class)'])

            for a_class in classes:
                mask = self.portfolio['Asset Class'] == a_class
                value_a_class = self.portfolio.loc[mask]['Current Value'].sum()
                share_per_asset_class.loc[a_class] = value_a_class/total_value
            
            print('\n'+str(share_per_asset_class.round(3)))
            
            plt.figure(figsize = (6, 6))
            plt.pie(share_per_asset_class['Share of total value (per asset class)'], labels = share_per_asset_class.index)
            plt.title('Share Of Total Portfolio Value by Asset Class')
            plt.tight_layout()
        
        if sector:
            sectors = self.portfolio['Sector'].unique()
            share_per_sector = pd.DataFrame(columns = ['Share of total value (per sector)'])

            for sctr in sectors:
                mask = self.portfolio['Sector'] == sctr
                value_sector = self.portfolio.loc[mask]['Current Value'].sum()
                share_per_sector.loc[sctr] = value_sector/total_value
            
            print('\n'+str(share_per_sector.round(3)))            
                
            plt.figure(figsize = (6, 6))
            plt.pie(share_per_sector['Share of total value (per sector)'], labels = share_per_sector.index)
            plt.title('Share Of Total Portfolio Value by Sector')
            plt.tight_layout()
            
        return
    
    # Formula to calculate the stock price at a given moment in time
    def S_T(self, T, t, St, simulations, mu, sigma):
        WT_minus_Wt = np.random.normal(0, np.sqrt(T - t), size=simulations)
        return St * np.exp((mu - 0.5 * (sigma**2)) * (T - t) + sigma * WT_minus_Wt)
    
    def portfolio_forecast(self, graph = True):
        # For the simulation, we assume (for simplicity) that the movement of the stocks are independent.
        # We model the stocks as geometric brownian motions.
        
        sim = 1000
        
        tickers = self.portfolio.index.tolist()
    
        # We assume 251 trading days in a year
        timeline = np.arange(0,251*5,1)

        simulated_portfolio = pd.DataFrame(columns=timeline)
        
        simulated_portfolio.loc['95% quantile'] = 0.0
        simulated_portfolio.loc['50% quantile'] = 0.0
        simulated_portfolio.loc['5% quantile'] = 0.0


        for ticker in tickers:
            # Determine initial price
            St_value = self.price(ticker, prd='1d').iloc[0, 0]
            St = np.full(sim, St_value)

            
            # Create empty array to store the stock values
            stockprice = np.zeros((sim,len(timeline)))
            stockprice[:,0] = St
            
            # Determine the initial drift term and standard deviation
            prices = yf.download(ticker, interval = '1d', auto_adjust=True, progress = False)['Close']
            mu = prices.pct_change().dropna().mean().iloc[0]
            sigma = prices.pct_change().dropna().std().iloc[0]
            
            # Loop over days in the next 5 years
            for i in range(1,len(timeline)):
                St = self.S_T(timeline[i],timeline[i-1], St, sim, mu, sigma)
                stockprice[:,i] = St
            
            # Determine quantiles based on stock simulations
            simulated_portfolio.loc['95% quantile'] += np.quantile(stockprice, 0.95 ,axis=0) * self.portfolio.loc[f'{ticker}']['Quantity']
            simulated_portfolio.loc['50% quantile'] += np.quantile(stockprice, 0.50 ,axis=0) * self.portfolio.loc[f'{ticker}']['Quantity']
            simulated_portfolio.loc['5% quantile'] += np.quantile(stockprice, 0.05 ,axis=0) * self.portfolio.loc[f'{ticker}']['Quantity']
        
        if graph == True:
            timeline_adj = np.arange(0, 5, 1/251)
            plt.figure()
            plt.plot(timeline_adj,simulated_portfolio.iloc[0],label='portfolio quantile 95%')
            plt.plot(timeline_adj,simulated_portfolio.iloc[1],label='portfolio quantile 50%')
            plt.plot(timeline_adj,simulated_portfolio.iloc[2],label='portfolio quantile 5%')
            plt.title('5 Year Portfolio Forecast')
            plt.xlabel('Forecast Year')
            plt.ylabel('Portfolio Value')
            plt.legend()
            plt.tight_layout()
            plt.show()
        
        return simulated_portfolio  
